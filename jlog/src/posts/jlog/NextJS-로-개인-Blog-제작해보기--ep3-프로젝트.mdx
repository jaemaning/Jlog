---
title: "NextJS 로 개인 Blog 제작해보기 - ep.3 프로젝트"
description: "개발환경 OS window Linux - Ubuntu (AWS EC2 server) IDE vscode FE Nextjs14 - App router Vanilla Extract @latest ContentLayer @latest storybook @latest jest"
date: 2024-05-07T07:04:54.540Z
tags: ["blog","font","nextjs","nextjs14","ttf","vanillaextract"]
category : "Python"
---
## 개발환경
### OS
window
Linux - Ubuntu (AWS EC2 server) 
### IDE
vscode
### FE
Nextjs14 - App router
Vanilla Extract @latest
ContentLayer @latest
storybook @latest
jest @latest
### tools
Figma
github




## Font 설정
제가 가장 좋아하는 폰트인 GowunDodam 폰트를 적용해보겠습니다.

https://noonnu.cc/font_page/734

여기서 ttf 파일을 다운로드 받고

web에서 읽어 올 수 있도록 public 폴더 아래 fonts 폴더를 새로 만들어 넣어주겠습니다.


![](/images/47aecc66-cd02-4873-bcc4-df89a94d8b3c-image.png)


이후 globalStyle을 지정해두었던 ```src/styles/globals.css.ts``` 로 이동하겠습니다.

```typescript
// src/styles/globals.css.ts

// fontFace 를 추가로 import 해줍니다.
import { globalStyle, fontFace } from '@vanilla-extract/css'

// fontFace 를 이용해 폰트를 저장합니다.
const GowunDodum = fontFace({
    src: 'url("/fonts/GowunDodum-Regular.ttf")',
})

globalStyle(
    'html, body', {
    padding : 0,
    margin : 0,
    // globalStyle 로 html, body 쪽에 font를 지정해 
    // 모든 상황에서 폰트를 사용할 수 있도록 지정하겠습니다.
    fontFamily : GowunDodum,
    height: '100%'
});

globalStyle(
    '*', {
    boxSizing: 'border-box'
});

globalStyle('a', {
    cursor : 'pointer',
    textDecoration : 'none',
    transition : 'all 0.3s',
    color : 'blue'
});

globalStyle('ol, ul', {
    listStyle : 'none'
});
```

이후 global.css.ts 를 root layout 에서 import 하여 적용합니다.

```typescript
// src/app/layout.tsx

import type { Metadata } from "next";
// global.css 를 가져와 사용합니다.
import '../styles/globals.css';

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html>
      <body>{children}</body>
    </html>
  );
}
```


![](/images/be59ec4b-137f-4e42-bc80-99ebbae659fa-image.png)



## Vanilla Extract Theme 설정
간단하게 테마를 설정하고 sprinkles 작성 후 darkMode, lightMode 버튼을 만들어보도록 하겠습니다. 과정 진행중 깜빡임 현상으로 인해 라이브러리 사용으로 변경 하여 진행했습니다.

먼저 `style.ts` 파일을 작성하겠습니다.

```typescript
// src/styles/style.ts

const fontSizes: { [key: string]: string } = {
    'extraSmall': '12px',
    'small': '14px',
    'medium': '16px',
    'mediumLarge': '18px',
    'large': '20px',
    'extraLarge': '23px'
};

const space : { [key: string]: string } = {
    'extraSmall': '0px',
    'small': '4px',
    'medium': '8px',
    'mediumLarge': '16px',
    'large': '24px',
    'extraLarge': '32px'
};

const colors = {
    'black': '#262425',
    'white': '#ffffff',
    'blue': '#bfdbfe',
    'gray-700': '#374151',
    'gray-800': '#eeeeee',
    'gray-900': '#121212'
};

const letterSpacing : {[key:string] : string} = {
    'tight': '0.05px',
    'normal': '0.06px',
    'wide': '0.07px'
};

const lineHeight : {[key:string] : string} = {
    'tight': '17px',
    'normal': '19px',
    'wide': '22px',
    'big': '26px'
};

export const style = {fontSizes, space, colors, letterSpacing, lineHeight};
```

간단히 버튼 컴포넌트를 테스트를 위해 만들어 보겠습니다.

```typescript
\src\components\button\button.tsx

import React from 'react';
import { buttonStyles } from '@/components/button/button.css';

interface ButtonProps {
    children: React.ReactNode;
    onClick?: () => void; // onClick 타입을 정의
}

const Button: React.FC<ButtonProps> = ({children, onClick}) => {
    return (
        <button className={buttonStyles} onClick={onClick}>{children}</button>
    );
};

export default Button;
```

테스트 환경에서 zero-runtime 적용을 위해 우선 재사용은 고려하지 않고 제작하였습니다. 추후 재사용성을 고려한 스타일링 component를 만들도록 하겠습니다.

```typescript
\src\components\button\button.css.ts

import { style } from '@vanilla-extract/css';
import { vars } from '@/styles/globalTheme.css';

export const buttonStyles = style({
    fontSize: vars.fontSizes.small,
    padding : vars.space.small,
    backgroundColor: vars.color['gray-700'],
    color: vars.color.white,
    width: '50px',
    height: '30px',
    borderRadius: '10px',
    border: 'none',
    cursor: 'pointer',
    margin: '10px',
});
```

### Vanilla Extract Sprinkles 설정
tailwind css 를 통해 반응형을 쉽게 구현할까 했지만 Vanilla Extract 공식문서를 보니 비슷한 기능을하는 Sprinkles 를 제공해주고 있었습니다. 이를 통해 반응형을 쉽게 구현해보도록 하겠습니다.

먼저 sprinkles 를 설치합니다.
```npm install @vanilla-extract/sprinkles date-fns --legacy-peer-deps```


![](/images/3ace7b0d-5034-4fa5-9f6f-e93c4892f604-image.png)


contentLayer 때 발생했던 nextjs14 버전과 호환문제가 여기서도 발생하네요,, `date-fns --legacy-peer-deps` 명령어를 뒤에 붙혀 강제 다운로드 하겠습니다.


먼저 `sprinkles.css.ts` 작성하겠습니다.

```typescript
// @/styles/sprinkles.css.ts

import {
    defineProperties,
    createSprinkles
} from '@vanilla-extract/sprinkles';

import { style } from './style';

const responsiveProperties = defineProperties({
    conditions: {
        mobile: {},
        tablet: { '@media': 'screen and (min-width: 768px)' },
        desktop: { '@media': 'screen and (min-width: 1024px)' }
    },
    defaultCondition: 'mobile',
    properties: {
        display: ['none', 'flex', 'block', 'inline'],
        flexDirection: ['row', 'column'],
        justifyContent: [
        'stretch',
        'flex-start',
        'center',
        'flex-end',
        'space-around',
        'space-between'
        ],
        alignItems: [
        'stretch',
        'flex-start',
        'center',
        'flex-end'
        ],
        paddingTop: style.space,
        paddingBottom: style.space,
        paddingLeft: style.space,
        paddingRight: style.space
    },
    shorthands: {
        padding: [
        'paddingTop',
        'paddingBottom',
        'paddingLeft',
        'paddingRight'
        ],
        paddingX: ['paddingLeft', 'paddingRight'],
        paddingY: ['paddingTop', 'paddingBottom'],
        placeItems: ['justifyContent', 'alignItems']
    }
});


const colorProperties = defineProperties({
    conditions: {
        lightMode: {},
        darkMode: { '@media': '(prefers-color-scheme: dark)' }
    },
    defaultCondition: 'lightMode',
    properties: {
        color: {
            light : style.colors.black,
            dark : style.colors.white
        },
        background: {
            light : style.colors.white,
            dark : style.colors.black
        }
    }
});

export const sprinkles = createSprinkles(
    responsiveProperties,
    colorProperties
);
```

우선은 세팅만 해두고 넘어가도록 하겠습니다.

### next-themes 적용
먼저 localStorage 를 사용해서 darkMode, lightMode 를 구분해야 새로고침이나, 페이지에 재접속시 저장이 되어있으므로 localStorage 로 구현하려고 하였으나 localStorage 값을 계속 트래킹하고 테마를 적용하는 과정이 매우 불편하였습니다. 이 불편함을 누군가 이미 알고 라이브러리화 해두지 않았을까 싶어 찾아보니 역시나 next-themes 라는 라이브러리에서 useTheme() 함수로 localStorage Theme 를 먼저 불러오고 쉽게 관리할 수 있었습니다.

추가적으로 기존 방식대로 다크모드 구현 시 nextjs 에서 깜빡임 현상이 발견된다는 이슈가 있었고 이 또한 next-themes 를 통해 해결할 수 있었습니다.

> 깜빡임 현상이란 ? 
화면 새로고침을 하게 되었을 때 페이지 렌더링이 일어나 부드럽게 페이지 전환되지 않고 초기 색상으로 전환되었다가 다시 돌아오는 현삼



### dark-mode 구현방법

아래와같이 2가지 파일을 새로 작성해야합니다. ThemeProvider next-themes 에서 제공하는 툴로 ThemeProvider 를 생성하고 아래처럼 작성해야합니다. 주의해야할 점은 use client 로 client component 로 themeProvider 를 생성해주어야합니다.

```typescript
'use client'

import { darkTheme, lightTheme } from '@/styles/globalTheme.css';
import { ThemeProvider } from 'next-themes';

const Provider = ({ children }: { children: React.ReactNode }) => {
    return (
        <ThemeProvider
        attribute="class"
        defaultTheme={'light'}
        value={{
            light: lightTheme,
            dark: darkTheme,
        }}
        >
        {children}
        </ThemeProvider>
    );
};
  
  export default Provider;

```

globalTheme.css.ts 파일을 생성해줍니다. 여기선 vanilla extract 의 assignVars 옵션을 활용해 Theme 이동을 간편히 하도록 구현하겠습니다.

```typescript
\src\styles\globalTheme.css.ts

import { 
    globalStyle,
    createThemeContract,
    createGlobalTheme,
    createTheme 
} from '@vanilla-extract/css';
import { style } from './style';


const themeColor = createThemeContract({
    color: {
      mainBackground: null,
      contentBackground: null,
      mainFontColor: null,
      borderColor: null,
      gradient: null,
      btnColor: null,
    },
  });
  
export const lightTheme = createTheme(themeColor, {
    color: {
        mainBackground: '#f7f9fa',
        contentBackground: '#ffffff',
        mainFontColor: '#2c2c2c',
        borderColor: '#cbc9f9',
        gradient: 'linear-gradient(#39598A, #79D7ED)',
        btnColor: '#f7f9fa',
    },
});

  
export const darkTheme = createTheme(themeColor, {
    color: {
        mainBackground: '#1d1d1d',
        contentBackground: '#2c2c2c',
        mainFontColor: '#ffffff',
        borderColor: '#b1b1b3',
        gradient: 'linear-gradient(#091236, #1E215D)',
        btnColor: '#1d1d1d',
    },
});


export const global = createGlobalTheme(':root', {
    color: style.colors,
    fontSizes: style.fontSizes,
    space : style.space
});

export const vars = { ...global, themeColor };


globalStyle('body', {
    fontSize: vars.fontSizes.medium,
    backgroundColor: vars.themeColor.color.mainBackground,
    userSelect: 'none',
    transition: 'all 0.25s linear'
});

```


![](/images/024daea9-3355-4279-83e0-dd19f57d0f5d-image.png)


간단한 darkModeBtn 을 만들어 테스트 해보도록 하겠습니다.

```typescript
'use client';

import * as style from './darkModeBtn.css';
import { useTheme } from 'next-themes';
import { useEffect, useState } from 'react';
import Button from '../button/button';

const DarkModeBtn = () => {
  const [mounted, setMounted] = useState(false);
  const { resolvedTheme, setTheme } = useTheme();

  useEffect(() => {
    setMounted(true);
  }, []);

  return (
    <div className={style.container}>
      <Button
        onClick={() => setTheme(resolvedTheme === 'light' ? 'dark' : 'light')}
        aria-label="DarkModeBtn"
      >
        버튼
      </Button>
    </div>
  );
};

export default DarkModeBtn;
```
확인 : 
- 최종적으로 새로고침 하여도 '깜빡임 현상' 없이 동작하는 것을 확인하였습니다.
- 버튼 색상이나 링크등의 추가적인 사항은 추후 세팅해보도록 하겠습니다.


![](/images/image-3.gif)



## 마무리하며,
Storybook 설정 및 테스트도 진행해 보고 싶었지만, 현재 vanilla-extract 를 공부하며 css 적용 방식에 대해 고민중에 있어 Storybook 세팅을 먼저 하지 않았습니다.

vanilla-extract 활용 방안을 말씀드리면,

> 1. vanilla extract 를 기존의 Styled-component 처럼 component level 에서 props 전달을 통해 구현하게 되면 vanilla-extract의 장점인 zero-runtime css 방식이 아니게 됩니다. css-in-js 방식으로 javascript 실행이 필요하게되어 브라우저 runtime 환경에서 실행되게 되기 때문입니다.
> 2. 이를 해결하기 위해 초기 구상한 toPropValue 함수를 통한 atomic design pattern 자체를 고민하게 되었습니다. 현재 생각한 방식은 vanilla-extract 에서 제공해주는 sprinkles 와 Recipe 를 통해 사전에 atomic 한 component에서 디자인 뼈대를 만들고 사용하려 합니다.

긴 글 읽어주셔서 감사합니다 :)

---

### 참고자료

출처 : https://yong-nyong.tistory.com/93
출처 : https://vanilla-extract.style/documentation/packages/sprinkles/#sprinkles
출처 : https://medium.com/catchtable/how-to-use-vanilla-extract-in-catchtable-b2c-6c4e712c471f